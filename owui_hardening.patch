*** Begin Patch
*** Update File: 10-multimodal-router/src/app.py
@@
-from __future__ import annotations
-import os, base64, httpx
+from __future__ import annotations
+import os, base64, httpx
 from typing import Optional, Dict, Any
-from fastapi import FastAPI, HTTPException, UploadFile, File, Form
+from fastapi import FastAPI, HTTPException, UploadFile, File, Form, Request
 from pydantic import BaseModel
+from urllib.parse import urlparse
+from .security import verify_sig
+
+MAX_BYTES = int(os.getenv("MM_MAX_DOWNLOAD_BYTES", "10485760"))  # 10 MB

 app = FastAPI(title="Multimodal Router", version="0.1.0")
@@
 def _or_headers() -> Dict[str, str]:
     if not OPENROUTER_API_KEY:
         raise HTTPException(500, "OPENROUTER_API_KEY missing")
     return {
         "Authorization": f"Bearer {OPENROUTER_API_KEY}",
         "HTTP-Referer":  "http://localhost",
         "X-Title":       "OWUI-Pipelines-MMR"
     }

+def _is_safe_url(u: str) -> bool:
+    try:
+        p = urlparse(u)
+        return p.scheme in ("http", "https")
+    except Exception:
+        return False
+
+async def _safe_get_bytes(url: str) -> bytes:
+    if not _is_safe_url(url):
+        raise HTTPException(400, "Invalid URL scheme")
+    async with httpx.AsyncClient(timeout=60) as c:
        r = await c.get(url, follow_redirects=True)
        r.raise_for_status()
        if int(r.headers.get("content-length", "0")) > MAX_BYTES:
            raise HTTPException(413, "Payload too large")
        return r.content[:MAX_BYTES]
+
 class ImageIn(BaseModel):
     image_url: Optional[str] = None
     image_b64: Optional[str] = None
     prompt:    Optional[str] = None
@@
-@app.post("/mm/image")
-async def analyze_image(req: ImageIn):
+@app.post("/mm/image")
+async def analyze_image(req: ImageIn, request: Request):
+    raw = await request.body()
+    await verify_sig(request, raw)
     """
     Analyze an image via a VLM on OpenRouter.
     Normalized output: { observations: [{label,text}], safety: [] }
     """
-    content_block = _make_image_content(req)
+    if req.image_url and not _is_safe_url(req.image_url):
+        raise HTTPException(400, "Invalid URL scheme")
+    content_block = _make_image_content(req)
     prompt = (req.prompt or PROMPT_IMAGE)[:1000]
@@
-@app.post("/mm/audio")
-async def analyze_audio(
+@app.post("/mm/audio")
+async def analyze_audio(
     file: UploadFile = File(...),
     prompt: str = Form(default=PROMPT_AUDIO),
     prefer_remote: bool = Form(default=False)
 ):
+    # Signature is optional here due to multipart; leave off for now or handle via query token if desired
     """
     Analyze audio: default path uses local STT, then summarizes.
     If prefer_remote=True and AUDIO_MODEL supports direct audio, route to OpenRouter.
     Normalized output: { transcript: "...", observations: [] }
     """
@@
 class AudioJsonIn(BaseModel):
     audio_url: Optional[str] = None
     audio_b64: Optional[str] = None
     prompt: Optional[str] = None
     prefer_remote: bool = False

-@app.post("/mm/audio_json")
-async def analyze_audio_json(req: AudioJsonIn):
+@app.post("/mm/audio_json")
+async def analyze_audio_json(req: AudioJsonIn, request: Request):
+    raw = await request.body()
+    await verify_sig(request, raw)
     if req.audio_url:
-        async with httpx.AsyncClient(timeout=60) as c:
-            r = await c.get(req.audio_url); r.raise_for_status()
-            data = r.content
+        data = await _safe_get_bytes(req.audio_url)
     elif req.audio_b64:
         data = base64.b64decode(req.audio_b64)
     else:
         raise HTTPException(400, "Provide audio_url or audio_b64")
*** End Patch

*** Begin Patch
*** Add File: 10-multimodal-router/src/security.py
+import os, hmac, hashlib
+from fastapi import Request, HTTPException
+
+SHARED = os.getenv("SUITE_SHARED_SECRET")
+
+async def verify_sig(request: Request, body: bytes):
+    """Optional HMAC verification for JSON POSTs. No-op if env var not set."""
+    if not SHARED:
+        return
+    sig = request.headers.get("X-SUITE-SIG", "")
+    mac = hmac.new(SHARED.encode(), body, hashlib.sha256).hexdigest()
+    if not hmac.compare_digest(sig, mac):
+        raise HTTPException(status_code=401, detail="bad signature")
*** End Patch

*** Begin Patch
*** Update File: 11-stt-tts-gateway/src/app.py
@@
-from __future__ import annotations
-import os, time, uuid
+from __future__ import annotations
+import os, time, uuid, threading
 from fastapi import FastAPI, UploadFile, File, HTTPException
 from pydantic import BaseModel
 from typing import Optional

 app = FastAPI(title="STT-TTS Gateway", version="0.1.0")

-AUDIO_STORAGE = os.getenv("AUDIO_STORAGE_PATH", "/tmp/owui_audio")
+AUD_DIR = os.getenv("AUDIO_STORAGE_PATH", "/tmp/owui_audio")
+TTL_SEC = int(os.getenv("STT_TTL_SECONDS", "900"))       # 15 min
+MAX_MB  = int(os.getenv("STT_MAX_UPLOAD_MB", "25"))
+os.makedirs(AUD_DIR, exist_ok=True)
+
+def _cleanup_loop():
+    while True:
+        now = time.time()
+        try:
+            for f in os.listdir(AUD_DIR):
+                p = os.path.join(AUD_DIR, f)
+                if os.path.isfile(p) and (now - os.path.getmtime(p) > TTL_SEC):
+                    try: os.remove(p)
+                    except Exception: pass
+        except Exception:
+            pass
+        time.sleep(120)
+
+@app.on_event("startup")
+def _start_cleanup():
+    threading.Thread(target=_cleanup_loop, daemon=True).start()

 @app.post("/stt")
 async def stt(file: UploadFile = File(...)):
-    # existing logic...
+    data = await file.read()
+    if len(data) > MAX_MB * 1024 * 1024:
+        raise HTTPException(413, "Audio too large")
+    # continue with your existing STT logic using `data` instead of file.read() calls
+    # save to AUD_DIR if needed, then transcribe...
     return {"text": "..."}
*** End Patch

*** Begin Patch
*** Update File: 00-pipelines-gateway/src/util/http.py
@@
-from __future__ import annotations
-import httpx
+from __future__ import annotations
+import httpx, os, hmac, hashlib, json
 from typing import Any, Dict

 class Svc:
-    def __init__(self, base: str): self.base = base.rstrip("/")
-    async def get(self, path: str, **params): 
+    def __init__(self, base: str):
+        self.base = base.rstrip("/")
+        self.secret = os.getenv("SUITE_SHARED_SECRET")  # optional
+    async def get(self, path: str, **params):
         async with httpx.AsyncClient(timeout=30) as c:
-            r = await c.get(f"{self.base}{path}", params=params); r.raise_for_status(); return r.json()
+            r = await c.get(f"{self.base}{path}", params=params)
+            r.raise_for_status()
+            return r.json()
     async def post(self, path: str, payload: Dict[str, Any]):
-        async with httpx.AsyncClient(timeout=60) as c:
-            r = await c.post(f"{self.base}{path}", json=payload); r.raise_for_status(); return r.json()
+        headers = {}
+        if self.secret is not None and payload is not None:
+            raw = json.dumps(payload, separators=(",",":")).encode()
+            mac = hmac.new(self.secret.encode(), raw, hashlib.sha256).hexdigest()
+            headers["X-SUITE-SIG"] = mac
+        async with httpx.AsyncClient(timeout=60) as c:
+            r = await c.post(f"{self.base}{path}", json=payload, headers=headers)
+            r.raise_for_status()
+            return r.json()
*** End Patch
